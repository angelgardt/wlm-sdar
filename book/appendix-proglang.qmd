# Языки программирования {#appendix-proglang}


Низкоуровневые языки

* близки к железу
* представляют собой команды для конкретного семейства процессоров
* асссемблер
* чтобы программа работала, её нужно писать под разные архитектуры, операционные системы --- это финансово затратно

Индустрия начала создавать языки более высокого уровня, которые самостоятельно справляются с этой рутиной.

Высокий уровень --- приближенность к восприятию человека за счет повышения уровня абстракций.

Программы становятся проще, короче, читаемее, понятнее.

Любая программа в исходном виде --- бесполезный набор текста. В конечном виде --- набор инструкций для конкретного процессора. Программа из языка, на котором она написана, должна трансформироваться в форму, способную выполниться процессором --- машинный набор инструкций.

Такой трансформацией занимаются специальные программы, которые называются трансляторы. Они делятся на компиляторы и интерпретаторы. Они получаются на вход текст исходной программы, но компилятор целиком анализирует и переводит программу с исходного языка в эквивалентную программу на машинном языке. После этого она может быть запущена и выполнена. Интерпретатор покомандно анализирует программу и сразу же выполняет, и не переводит её в эквивалентный вид. Существуют промежуточные варианты, когда программа, например, транслируется в байт-код, который затем интерпретируется.

То есть, чтобы создать язык надо написать транслятор языка и документацию, чтобы программист мог правильно написать программу на этом языке --- синтаксис. Синтаксис определяется транслятором языка. Это то, что транслятор ожидаем получить на вход для корректной обработки программы.

В случае нарушения синтаксиса компилятор выдаст ошибку по время обработки программы, интерпретатор --- во время выполнения этого куска кода.

Исходная программа (модули) -> препроцессор (сборка) -> программа -> компилятор -> ассемблерная программа -> компилатор ассемблера -> объектные модули -> компоновщик -> целевая программа (на машинном языке, исполняемый файл) -> ОС (исполнение программы (выделение памяти, загрузка, передача управления, взаимодействие с внешними устройствами))

Процесс компляции отличается под каждую ОС и под каждую архитектуру процессора.

Парадигмы и типизация данных

Парадигмы --- стиль написания кода. Их много, но основных два --- императивный и декларативный. Их различия --- в пути решения задачи: КАК реализовать и ЧТО реализовать?

В императивном стиле пошагово расписывается как решить задачу в виде последовательных действий, которые должны 
привести к результату. Большинство языков.
В декларативном стиле не расписываются шаги реализации, описывается только, что нужно сделать (SQL).

Императивная парадигма разделяется еще на несколько ветвей, две основные --- процедурное и объекто-ориентированное.

В процедурном стиле вся программа состоит из набора процедур и функций, которые могут вызывать друг друга в ходе своего исполнения. Функции --- это подпрограммы, куски кода, разбросанные в памяти по разным адресам.
Создание кода на одних функциях приводит к двум проблемам: плохой расширяемости и трудноподдерживаемости кода. Единственный выход --- упрощение, поэтому придумали ООП.

ООП позволяет оперировать такими сущностями, как объекты. Это очередная абстракция, для облегчения построения архитектуры программ, которая присутствует во многих высокоуровневых языках.

Несмотря на это многие языки являются мультипарадигменными --- в них можно использовать как процедурный, так и объектор-ориентированный стиль вместе.


Типизация данных. Изначально все данные, которые лежат в памяти, не имеют никакого типа --- это просто двоичные числа в представлении людей. Но при разработки языков для удобства манипуляции данными их разбили на некоторые типы. Языки начали разделяться на изыки с типизацией и языки без типизации. Данные без типа --- это просто последовательности бит, которые присутствуют в низкоуровневых языка вроде ассемблера.

99% языко содержит типизацию данных.
Явная/неявная: при явной типизации необходимо эксплицитно указывать, какой тип данных, при неявной тип данных задается компилятором. 

Статическая/динамическая: при статической типизации проверка и установка типов данных происходит на этапе компиляции, а в динамической --- на этапе выполнения программы. Языка со статической типизацией работают быстрее.

Сильная/слабая (строгая/нестрогая): сильная типизация не позволяет смешивать различные типы друг с другом, при слабой типизации автоматически выполняется приведение типов, что может приводить к неоднозначным результатам.







## Транслятор языка {#proglang-translator}

## Классификации языков программирования {#proglang-classifications}

### По задачам {#proglang-classification-tasks}

Языки программирования общего назначения

### По парадигме {#proglang-classification-pardigm}

Объектно-ориентированные
